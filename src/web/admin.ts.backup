// src/web/admin.ts
import { Router } from "express";
import { JsonRpcProvider, Contract } from "ethers";
import { getConfig } from "../config.js";
import { registerCommandsForApprovedGuilds } from "../services/command_registry.js";
import { getCommandsJson } from "../services/commands_def.js";
import { prisma } from "../services/db.js";
import { getActiveTokens } from "../services/token.js";
import { ABSTRACT_RPC_URL } from "../config.js";

export const adminRouter = Router();
const ADMIN_SECRET = process.env.ADMIN_SECRET || "";

const ERC20_ABI = [
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)"
];

// simple bearer auth middleware
adminRouter.use((req, res, next) => {
  const got = req.headers.authorization || "";
  if (!ADMIN_SECRET || got !== `Bearer ${ADMIN_SECRET}`) {
    return res.status(401).json({ ok: false, error: "unauthorized" });
  }
  next();
});

// health
adminRouter.get("/ping", (_req, res) => res.json({ ok: true }));

// reload AppConfig cache (limits, fees, etc.)
adminRouter.post("/reload-config", async (_req, res) => {
  try {
    await getConfig(true);
    res.json({ ok: true, reloaded: "config" });
  } catch (e: any) {
    res.status(500).json({ ok: false, error: e?.message || "reload-config failed" });
  }
});

// re-register slash commands for all approved guilds
adminRouter.post("/reload-commands", async (_req, res) => {
  try {
    const commands = getCommandsJson();
    await registerCommandsForApprovedGuilds(commands);
    res.json({ ok: true, reloaded: "commands" });
  } catch (e: any) {
    res.status(500).json({ ok: false, error: e?.message || "reload-commands failed" });
  }
});

// do both
adminRouter.post("/reload-all", async (_req, res) => {
  try {
    await (await import("../config.js")).getConfig(true);
    const commands = getCommandsJson();
    await registerCommandsForApprovedGuilds(commands);
    res.json({ ok: true, reloaded: ["config", "commands"] });
  } catch (e: any) {
    res.status(500).json({ ok: false, error: e?.message || "reload-all failed" });
  }
});

// ============= TOKEN MANAGEMENT =============

// Get all tokens
adminRouter.get("/tokens", async (_req, res) => {
  try {
    const tokens = await prisma.token.findMany({ orderBy: { createdAt: "desc" } });
    res.json({ ok: true, tokens });
  } catch {
    res.status(500).json({ ok: false, error: "Failed to fetch tokens" });
  }
});

// Add new token
adminRouter.post("/tokens", async (req, res) => {
  try {
    const { address, minDeposit = 1, minWithdraw = 1 } = req.body;

    if (!address || !/^0x[a-fA-F0-9]{40}$/.test(address)) {
      return res.status(400).json({ ok: false, error: "Invalid contract address" });
    }

    const normalizedAddress = address.toLowerCase();

    // Check if token already exists
    const existing = await prisma.token.findUnique({
      where: { address: normalizedAddress }
    });
    if (existing) {
      return res.status(400).json({ ok: false, error: "Token already exists" });
    }

    // Fetch token metadata from contract
    const provider = new JsonRpcProvider(ABSTRACT_RPC_URL);
    const contract = new Contract(normalizedAddress, ERC20_ABI, provider);

    const [name, symbol, decimals] = await Promise.all([
      contract.name(),
      contract.symbol(),
      contract.decimals()
    ]);

    // Create token record
    const token = await prisma.token.create({
      data: {
        address: normalizedAddress,
        symbol,
        decimals: Number(decimals),
        minDeposit: String(minDeposit),
        minWithdraw: String(minWithdraw),
        active: true
      }
    });

    res.json({
      ok: true,
      token,
      message: `Added ${symbol} token`
    });
  } catch (error: any) {
    console.error("Token add error:", error);
    res.status(500).json({
      ok: false,
      error: error.message?.includes("call revert")
        ? "Invalid token contract or not deployed on Abstract"
        : "Failed to add token"
    });
  }
});

// Update token
adminRouter.put("/tokens/:id", async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    const { active, minDeposit, minWithdraw } = req.body;

    const token = await prisma.token.update({
      where: { id },
      data: {
        ...(typeof active === "boolean" && { active }),
        ...(minDeposit !== undefined && { minDeposit: String(minDeposit) }),
        ...(minWithdraw !== undefined && { minWithdraw: String(minWithdraw) })
      }
    });

    res.json({ ok: true, token });
  } catch {
    res.status(500).json({ ok: false, error: "Failed to update token" });
  }
});

// Refresh token cache endpoint
adminRouter.post("/tokens/refresh", async (_req, res) => {
  try {
    await getActiveTokens(true);
    res.json({ ok: true, message: "Token cache refreshed" });
  } catch {
    res.status(500).json({ ok: false, error: "Failed to refresh cache" });
  }
});

// ============= SERVER MANAGEMENT =============

// Get server approvals
adminRouter.get("/servers", async (_req, res) => {
  try {
    const servers = await prisma.approvedServer.findMany({
      orderBy: { createdAt: "desc" }
    });
    res.json({ ok: true, servers });
  } catch {
    res.status(500).json({ ok: false, error: "Failed to fetch servers" });
  }
});

// Add/approve new server
adminRouter.post("/servers", async (req, res) => {
  try {
    const { guildId, note = "" } = req.body;

    if (!guildId) {
      return res.status(400).json({ ok: false, error: "Guild ID required" });
    }

    const server = await prisma.approvedServer.upsert({
      where: { guildId },
      update: { enabled: true, note },
      create: { guildId, note, enabled: true }
    });

    res.json({ ok: true, server });
  } catch {
    res.status(500).json({ ok: false, error: "Failed to add server" });
  }
});

// Update server status
adminRouter.put("/servers/:id", async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    const { enabled, note } = req.body;

    const server = await prisma.approvedServer.update({
      where: { id },
      data: {
        ...(typeof enabled === "boolean" && { enabled }),
        ...(note !== undefined && { note })
      }
    });

    res.json({ ok: true, server });
  } catch {
    res.status(500).json({ ok: false, error: "Failed to update server" });
  }
});

// ============= CONFIG (fees, limits, etc.) =============

// Get current config
adminRouter.get("/config", async (_req, res) => {
  try {
    const config = await prisma.appConfig.findFirst({
      orderBy: { id: "desc" }
    });
    res.json({ ok: true, config });
  } catch {
    res.status(500).json({ ok: false, error: "Failed to fetch config" });
  }
});

// Update global config (auto-refresh cache). Set withdrawMaxPerTx=0 for "no cap".
adminRouter.put("/config", async (req, res) => {
  try {
    const {
      tipFeeBps,
      houseFeeBps,
      minDeposit,
      minWithdraw,
      withdrawMaxPerTx,   // number or string; "0" means no cap (command should respect)
      withdrawDailyCap
    } = req.body;

    // Get existing config or create default
    const existing = await prisma.appConfig.findFirst({ orderBy: { id: "desc" } });
    const id = existing?.id ?? 1;

    const config = await prisma.appConfig.upsert({
      where: { id },
      update: {
        ...(tipFeeBps !== undefined && { tipFeeBps: Number(tipFeeBps) }),
        ...(houseFeeBps !== undefined && { houseFeeBps: Number(houseFeeBps) }),
        ...(minDeposit !== undefined && { minDeposit: String(minDeposit) }),
        ...(minWithdraw !== undefined && { minWithdraw: String(minWithdraw) }),
        ...(withdrawMaxPerTx !== undefined && { withdrawMaxPerTx: String(withdrawMaxPerTx) }),
        ...(withdrawDailyCap !== undefined && { withdrawDailyCap: String(withdrawDailyCap) })
      },
      create: {
        tipFeeBps: Number(tipFeeBps ?? 100),
        houseFeeBps: Number(houseFeeBps ?? 200),
        minDeposit: String(minDeposit ?? 50),
        minWithdraw: String(minWithdraw ?? 50),
        withdrawMaxPerTx: String(withdrawMaxPerTx ?? 50),
        withdrawDailyCap: String(withdrawDailyCap ?? 500)
      }
    });

    // Auto-refresh cache so changes apply immediately
    await getConfig(true);

    res.json({ ok: true, config, message: "Configuration updated" });
  } catch (error: any) {
    res.status(500).json({ ok: false, error: "Failed to update config" });
  }
});

// ============= ANALYTICS =============

// Get basic platform stats
adminRouter.get("/stats", async (_req, res) => {
  try {
    const [
      totalUsers,
      totalMatches,
      totalTips,
      activeTokens,
      recentMatches,
      topTippers
    ] = await Promise.all([
      prisma.user.count(),
      prisma.match.count(),
      prisma.tip.count(),
      prisma.token.count({ where: { active: true } }),
      prisma.match.count({
        where: { createdAt: { gte: new Date(Date.now() - 24 * 60 * 60 * 1000) } }
      }),
      prisma.user.findMany({
        orderBy: { wins: "desc" },
        take: 5,
        select: { discordId: true, wins: true, losses: true }
      })
    ]);

    res.json({
      ok: true,
      stats: {
        totalUsers,
        totalMatches,
        totalTips,
        activeTokens,
        recentMatches,
        topTippers
      }
    });
  } catch {
    res.status(500).json({ ok: false, error: "Failed to fetch stats" });
  }
});

// ============= FEES / RAKE ANALYTICS =============

// Sum house earnings by token (rake + tip fees)
// GET /admin/fees/summary?since=YYYY-MM-DD&until=YYYY-MM-DD
adminRouter.get("/fees/summary", async (req, res) => {
  try {
    const since = req.query.since ? new Date(String(req.query.since)) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    const until = req.query.until ? new Date(String(req.query.until)) : new Date();

    // TIP FEES (Transaction.fee where type='TIP')
    const tipFees = await prisma.transaction.groupBy({
      by: ["tokenId"],
      where: {
        type: "TIP",
        tokenId: { not: null },
        createdAt: { gte: since, lte: until }
      },
      _sum: { fee: true }
    });

    // MATCH RAKE (Match.rakeAtomic)
    const matchRake = await prisma.match.groupBy({
      by: ["tokenId"],
      where: {
        status: "SETTLED",
        createdAt: { gte: since, lte: until }
      },
      _sum: { rakeAtomic: true }
    });

    const tokenIds = [
      ...new Set([
        ...tipFees.map(x => x.tokenId!),
        ...matchRake.map(x => x.tokenId!)
      ])
    ];
    const tokens = await prisma.token.findMany({
      where: { id: { in: tokenIds } },
      select: { id: true, symbol: true }
    });
    const tokMap = new Map(tokens.map(t => [t.id, t.symbol]));

    const perToken: Record<number, { tokenId: number; symbol: string; tipFees: string; matchRake: string; total: string }> = {};

    for (const r of tipFees) {
      const id = r.tokenId!;
      const symbol = tokMap.get(id) ?? `#${id}`;
      const fee = String(r._sum.fee ?? "0");
      perToken[id] ??= { tokenId: id, symbol, tipFees: "0", matchRake: "0", total: "0" };
      perToken[id].tipFees = fee;
    }

    for (const r of matchRake) {
      const id = r.tokenId!;
      const symbol = tokMap.get(id) ?? `#${id}`;
      const rake = String(r._sum.rakeAtomic ?? "0");
      perToken[id] ??= { tokenId: id, symbol, tipFees: "0", matchRake: "0", total: "0" };
      perToken[id].matchRake = rake;
    }

    for (const row of Object.values(perToken)) {
      const t = (parseFloat(row.tipFees) || 0) + (parseFloat(row.matchRake) || 0);
      row.total = String(t);
    }

    const grandTotal = Object.values(perToken).reduce((acc, r) => acc + (parseFloat(r.total) || 0), 0);

    res.json({
      ok: true,
      since: since.toISOString(),
      until: until.toISOString(),
      perToken: Object.values(perToken).sort((a, b) => a.symbol.localeCompare(b.symbol)),
      grandTotal: String(grandTotal)
    });
  } catch (error: any) {
    res.status(500).json({ ok: false, error: error?.message || "fees/summary failed" });
  }
});

// Per-server (guild) split for house earnings
// GET /admin/fees/by-server?since=YYYY-MM-DD&until=YYYY-MM-DD
// Requires MATCH_RAKE rows in Transaction with guildId to attribute rake per server.
adminRouter.get("/fees/by-server", async (req, res) => {
  try {
    const since = req.query.since ? new Date(String(req.query.since)) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    const until = req.query.until ? new Date(String(req.query.until)) : new Date();

    // TIP fee rows (fee lives on Transaction)
    const tipRows = await prisma.transaction.findMany({
      where: {
        type: "TIP",
        tokenId: { not: null },
        createdAt: { gte: since, lte: until }
      },
      select: { guildId: true, tokenId: true, fee: true }
    });

    // MATCH_RAKE rows
    const rakeRows = await prisma.transaction.findMany({
      where: {
        type: "MATCH_RAKE",
        tokenId: { not: null },
        createdAt: { gte: since, lte: until }
      },
      select: { guildId: true, tokenId: true, amount: true }
    });

    const tokenIds = Array.from(new Set([...tipRows.map(r => r.tokenId!), ...rakeRows.map(r => r.tokenId!)]));
    const tokens = await prisma.token.findMany({ where: { id: { in: tokenIds } }, select: { id: true, symbol: true } });
    const tokMap = new Map(tokens.map(t => [t.id, t.symbol]));

    // agg[guildId][tokenId] = { tipFees, matchRake }
    const agg: Record<string, Record<number, { tipFees: number; matchRake: number }>> = {};

    for (const r of tipRows) {
      const g = r.guildId ?? "(unknown)";
      const t = r.tokenId!;
      agg[g] ??= {};
      agg[g][t] ??= { tipFees: 0, matchRake: 0 };
      agg[g][t].tipFees += parseFloat(String(r.fee ?? "0")) || 0;
    }
    for (const r of rakeRows) {
      const g = r.guildId ?? "(unknown)";
      const t = r.tokenId!;
      agg[g] ??= {};
      agg[g][t] ??= { tipFees: 0, matchRake: 0 };
      agg[g][t].matchRake += parseFloat(String(r.amount ?? "0")) || 0;
    }

    const rows = Object.entries(agg).flatMap(([guildId, byToken]) =>
      Object.entries(byToken).map(([tid, v]) => ({
        guildId,
        tokenId: Number(tid),
        symbol: tokMap.get(Number(tid)) ?? `#${tid}`,
        tipFees: String(v.tipFees),
        matchRake: String(v.matchRake),
        total: String(v.tipFees + v.matchRake)
      }))
    );

    const totalsByGuild: Record<string, number> = {};
    for (const r of rows) {
      totalsByGuild[r.guildId] = (totalsByGuild[r.guildId] || 0) + parseFloat(r.total);
    }

    res.json({
      ok: true,
      since: since.toISOString(),
      until: until.toISOString(),
      perGuild: rows.sort((a, b) => (a.guildId + a.symbol).localeCompare(b.guildId + b.symbol)),
      totalsByGuild,
      grandTotal: rows.reduce((s, r) => s + parseFloat(r.total), 0)
    });
  } catch (e: any) {
    res.status(500).json({ ok: false, error: e?.message || "by-server failed" });
  }
});

// Daily series (optionally per server)
// GET /admin/fees/daily?days=30&guildId=<id>
adminRouter.get("/fees/daily", async (req, res) => {
  try {
    const days = Math.max(1, Math.min(180, Number(req.query.days ?? 30)));
    const filterGuild = req.query.guildId ? String(req.query.guildId) : undefined;

    const start = new Date();
    start.setUTCHours(0, 0, 0, 0);
    start.setDate(start.getDate() - (days - 1));
    const end = new Date();

    const whereBase = {
      tokenId: { not: null } as any,
      createdAt: { gte: start, lte: end },
      ...(filterGuild ? { guildId: filterGuild } : {})
    };

    const [tipTxs, rakeTxs, tokens] = await Promise.all([
      prisma.transaction.findMany({
        where: { ...whereBase, type: "TIP" },
        select: { tokenId: true, fee: true, createdAt: true }
      }),
      prisma.transaction.findMany({
        where: { ...whereBase, type: "MATCH_RAKE" },
        select: { tokenId: true, amount: true, createdAt: true }
      }),
      prisma.token.findMany({ select: { id: true, symbol: true } })
    ]);

    const tokMap = new Map(tokens.map(t => [t.id, t.symbol]));
    const fmtDay = (d: Date) => d.toISOString().slice(0, 10);
    const daysList: string[] = [];
    for (let i = 0; i < days; i++) {
      const d = new Date(start);
      d.setDate(start.getDate() + i);
      daysList.push(fmtDay(d));
    }

    type Series = Record<string /*symbol*/, Record<string /*day*/, number>>;
    const tipSeries: Series = {};
    const rakeSeries: Series = {};

    for (const symbol of new Set(tokens.map(t => t.symbol))) {
      tipSeries[symbol] = Object.fromEntries(daysList.map(d => [d, 0]));
      rakeSeries[symbol] = Object.fromEntries(daysList.map(d => [d, 0]));
    }

    for (const r of tipTxs) {
      const day = fmtDay(new Date(r.createdAt));
      if (!daysList.includes(day)) continue;
      const sym = tokMap.get(r.tokenId!) ?? `#${r.tokenId}`;
      tipSeries[sym] ??= Object.fromEntries(daysList.map(d => [d, 0]));
      tipSeries[sym][day] += parseFloat(String(r.fee ?? "0")) || 0;
    }

    for (const r of rakeTxs) {
      const day = fmtDay(new Date(r.createdAt));
      if (!daysList.includes(day)) continue;
      const sym = tokMap.get(r.tokenId!) ?? `#${r.tokenId}`;
      rakeSeries[sym] ??= Object.fromEntries(daysList.map(d => [d, 0]));
      rakeSeries[sym][day] += parseFloat(String(r.amount ?? "0")) || 0;
    }

    res.json({
      ok: true,
      guildId: filterGuild ?? null,
      days,
      start: daysList[0],
      end: daysList[daysList.length - 1],
      tipFeesDaily: tipSeries,
      matchRakeDaily: rakeSeries
    });
  } catch (e: any) {
    res.status(500).json({ ok: false, error: e?.message || "fees/daily failed" });
  }
});

// CSV export (per token, per guild, time-bounded)
// GET /admin/fees/export.csv?since=YYYY-MM-DD&until=YYYY-MM-DD&guildId=<id>
adminRouter.get("/fees/export.csv", async (req, res) => {
  try {
    const since = req.query.since ? new Date(String(req.query.since)) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    const until = req.query.until ? new Date(String(req.query.until)) : new Date();
    const filterGuild = req.query.guildId ? String(req.query.guildId) : undefined;

    const whereBase = {
      tokenId: { not: null } as any,
      createdAt: { gte: since, lte: until },
      ...(filterGuild ? { guildId: filterGuild } : {})
    };

    const [tipTxs, rakeTxs, tokens] = await Promise.all([
      prisma.transaction.findMany({
        where: { ...whereBase, type: "TIP" },
        select: { createdAt: true, guildId: true, tokenId: true, fee: true }
      }),
      prisma.transaction.findMany({
        where: { ...whereBase, type: "MATCH_RAKE" },
        select: { createdAt: true, guildId: true, tokenId: true, amount: true }
      }),
      prisma.token.findMany({ select: { id: true, symbol: true } })
    ]);
    const tokMap = new Map(tokens.map(t => [t.id, t.symbol]));

    type Row = { date: string; guildId: string; token: string; category: "TIP_FEE" | "MATCH_RAKE"; amount: string };
    const rows: Row[] = [];

    for (const r of tipTxs) {
      rows.push({
        date: new Date(r.createdAt).toISOString(),
        guildId: r.guildId ?? "",
        token: tokMap.get(r.tokenId!) ?? `#${r.tokenId}`,
        category: "TIP_FEE",
        amount: String(r.fee ?? "0")
      });
    }
    for (const r of rakeTxs) {
      rows.push({
        date: new Date(r.createdAt).toISOString(),
        guildId: r.guildId ?? "",
        token: tokMap.get(r.tokenId!) ?? `#${r.tokenId}`,
        category: "MATCH_RAKE",
        amount: String(r.amount ?? "0")
      });
    }

    rows.sort((a, b) => a.date.localeCompare(b.date));

    res.setHeader("Content-Type", "text/csv; charset=utf-8");
    res.setHeader("Content-Disposition", `attachment; filename="fees_${(filterGuild || "all")}.csv"`);

    res.write("date,guildId,token,category,amount\n");
    for (const r of rows) {
      const line = [
        r.date,
        r.guildId,
        r.token.includes(",") ? `"${r.token}"` : r.token,
        r.category,
        r.amount
      ].join(",");
      res.write(line + "\n");
    }
    res.end();
  } catch (e: any) {
    res.status(500).json({ ok: false, error: e?.message || "fees/export failed" });
  }
});
