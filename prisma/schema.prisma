datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Notification {
  id        String    @id @default(cuid())
  userId    Int
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String
  payload   Json
  createdAt DateTime  @default(now())
  sentAt    DateTime?

  @@index([userId, sentAt])
}

model User {
  id         Int      @id @default(autoincrement())
  discordId  String   @unique
  agwAddress String?
  wins       Int      @default(0)
  losses     Int      @default(0)
  ties       Int      @default(0)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Gaming relations
  challenger Match[] @relation("Challenger")
  joiner     Match[] @relation("Joiner")

  // Tipping relations
  tipsSent     Tip[] @relation("TipFrom")
  tipsReceived Tip[] @relation("TipTo")

  // Group tipping relations
  groupTipsCreated GroupTip[]      @relation("GroupTipCreator")
  groupTipsClaimed GroupTipClaim[] @relation("GroupTipClaims")

  // Balances
  balances UserBalance[]

  // Memberships (BACK-RELATION added)
  tierMemberships TierMembership[]

  // Notifications
  notifications Notification[]

  @@index([agwAddress])
  @@index([createdAt])
}

model Tier {
  id           Int      @id @default(autoincrement())
  name         String
  description  String?  @db.Text
  priceAmount  Decimal? // legacy/optional
  durationDays Int
  tipTaxFree   Boolean  @default(false)
  active       Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  memberships TierMembership[]

  // ✅ back-relation to TierPrice
  prices TierPrice[] @relation("TierToPrices")

  @@index([active])
}

model TierPrice {
  id        Int      @id @default(autoincrement())
  tierId    Int
  tokenId   Int
  amount    Decimal
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // ✅ name both sides of the relation
  tier  Tier  @relation("TierToPrices", fields: [tierId], references: [id], onDelete: Cascade)
  token Token @relation("TokenToTierPrices", fields: [tokenId], references: [id], onDelete: Restrict)

  @@unique([tierId, tokenId])
  @@index([tokenId])
}

enum TierMembershipStatus {
  ACTIVE
  EXPIRED
  REVOKED
}

model TierMembership {
  id        Int                  @id @default(autoincrement())
  userId    Int
  tierId    Int
  startedAt DateTime             @default(now())
  expiresAt DateTime
  txHash    String?              @unique
  status    TierMembershipStatus @default(ACTIVE)
  createdAt DateTime             @default(now())

  // BACK-RELATIONS now have opposites on User and Tier
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  tier Tier @relation(fields: [tierId], references: [id], onDelete: Restrict)

  @@unique([userId, tierId, status], map: "uniq_user_tier_status") // one ACTIVE membership per (user,tier)
  @@index([userId, tierId, expiresAt])
  @@index([userId, status, expiresAt])
}

model Match {
  id             Int       @id @default(autoincrement())
  status         String
  wagerAtomic    Decimal   @default(0)
  potAtomic      Decimal   @default(0)
  tokenId        Int
  challengerId   Int?
  joinerId       Int?
  challengerMove String?
  joinerMove     String?
  result         String?
  rakeAtomic     Decimal   @default(0)
  winnerUserId   Int?
  messageId      String?
  channelId      String?
  offerDeadline  DateTime?
  createdAt      DateTime  @default(now())

  Challenger User? @relation("Challenger", fields: [challengerId], references: [id])
  Joiner     User? @relation("Joiner", fields: [joinerId], references: [id])
  Token      Token @relation(fields: [tokenId], references: [id])

  @@index([status, offerDeadline])
  @@index([createdAt])
  @@index([challengerId])
  @@index([joinerId])
}

enum TipStatus {
  PENDING
  COMPLETED
  REFUNDED
}

model Tip {
  id           Int       @id @default(autoincrement())
  fromUserId   Int?
  toUserId     Int?
  tokenId      Int
  amountAtomic Decimal   @default(0)
  feeAtomic    Decimal   @default(0)
  taxAtomic    Decimal   @default(0) // exact tax amount debited at creation
  note         String?
  status       TipStatus @default(PENDING)
  refundedAt   DateTime?
  createdAt    DateTime  @default(now())

  From  User?  @relation("TipFrom", fields: [fromUserId], references: [id])
  To    User?  @relation("TipTo", fields: [toUserId], references: [id])
  Token Token @relation(fields: [tokenId], references: [id])

  @@index([createdAt])
  @@index([status])
  @@index([fromUserId])
  @@index([toUserId])
}

enum GroupTipStatus {
  PENDING
  ACTIVE
  EXPIRED
  REFUNDED
  FAILED
}

model GroupTip {
  id          Int      @id @default(autoincrement())
  creatorId   Int?
  tokenId     Int
  totalAmount Decimal
  taxAtomic   Decimal  @default(0) // exact tax amount debited at creation
  duration    Int
  messageId   String?
  channelId   String?
  guildId     String?
  status      String   // Keep as String for backward compatibility
  expiresAt   DateTime
  refundedAt  DateTime?
  createdAt   DateTime @default(now())

  Creator User?           @relation("GroupTipCreator", fields: [creatorId], references: [id])
  Token   Token           @relation(fields: [tokenId], references: [id])
  claims  GroupTipClaim[]

  @@index([status, expiresAt])
  @@index([createdAt])
  @@index([creatorId])
  @@index([guildId])
}

enum GroupContributionStatus {
  PENDING
  CLAIMED
  REFUNDED
}

model GroupTipClaim {
  id         Int                      @id @default(autoincrement())
  groupTipId Int
  userId     Int?
  status     GroupContributionStatus  @default(PENDING)
  claimedAt  DateTime?
  refundedAt DateTime?
  createdAt  DateTime                 @default(now())

  GroupTip GroupTip @relation(fields: [groupTipId], references: [id])
  User     User?    @relation("GroupTipClaims", fields: [userId], references: [id])

  @@unique([groupTipId, userId])
  @@index([status])
  @@index([groupTipId])
  @@index([userId])
}

model Token {
  id               Int      @id @default(autoincrement())
  address          String   @unique
  symbol           String   @unique
  decimals         Int
  active           Boolean  @default(true)
  minDeposit       Decimal  @default(50)
  minWithdraw      Decimal  @default(50)
  tipFeeBps        Int?
  houseFeeBps      Int?
  withdrawMaxPerTx Decimal?
  withdrawDailyCap Decimal?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  balances  UserBalance[]
  matches   Match[]
  tips      Tip[]
  groupTips GroupTip[]

  // ❌ REMOVE this old line:
  // tiers     Tier[]

  // ✅ back-relation to TierPrice
  tierPrices TierPrice[] @relation("TokenToTierPrices")
}

model UserBalance {
  id      Int     @id @default(autoincrement())
  userId  Int
  tokenId Int
  amount  Decimal @default(0)

  User  User  @relation(fields: [userId], references: [id])
  Token Token @relation(fields: [tokenId], references: [id])

  @@unique([userId, tokenId])
}

model ProcessedDeposit {
  key       String   @id
  createdAt DateTime @default(now())
}

model DepositCursor {
  name      String   @id
  blockHex  String
  updatedAt DateTime @updatedAt
}

model AppConfig {
  id               Int      @id @default(autoincrement())
  minDeposit       Decimal  @default(50)
  minWithdraw      Decimal  @default(50)
  withdrawMaxPerTx Decimal  @default(50)
  withdrawDailyCap Decimal  @default(500)
  houseFeeBps      Int      @default(200)
  tipFeeBps        Int      @default(100)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model ApprovedServer {
  id        Int      @id @default(autoincrement())
  guildId   String   @unique
  note      String?
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Ad {
  id        Int      @id @default(autoincrement())
  text      String
  url       String?
  active    Boolean  @default(true)
  weight    Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Transaction {
  id          Int      @id @default(autoincrement())
  type        String
  userId      Int?
  otherUserId Int?
  guildId     String?
  tokenId     Int?
  amount      Decimal
  fee         Decimal  @default(0)
  txHash      String?
  metadata    String?
  createdAt   DateTime @default(now())

  @@index([createdAt])
  @@index([guildId])
  @@index([type])
  @@index([userId])
}

model WebhookEvent {
  id        Int      @id @default(autoincrement())
  source    String
  key       String   @unique
  status    String
  payload   String
  createdAt DateTime @default(now())

  @@index([createdAt])
}
