datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Notification {
  id        String    @id @default(cuid())
  userId    Int
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String
  payload   Json
  createdAt DateTime  @default(now())
  sentAt    DateTime?

  @@index([userId, sentAt])
}

model User {
  id         Int      @id @default(autoincrement())
  discordId  String   @unique
  agwAddress String?
  wins       Int      @default(0)
  losses     Int      @default(0)
  ties       Int      @default(0)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Gaming relations
  challenger Match[] @relation("Challenger")
  joiner     Match[] @relation("Joiner")

  // Tipping relations
  tipsSent     Tip[] @relation("TipFrom")
  tipsReceived Tip[] @relation("TipTo")

  // Group tipping relations
  groupTipsCreated GroupTip[]      @relation("GroupTipCreator")
  groupTipsClaimed GroupTipClaim[] @relation("GroupTipClaims")

  // Balances
  balances UserBalance[]

  // Memberships (BACK-RELATION added)
  tierMemberships TierMembership[]

  // Notifications
  notifications Notification[]

  // PenguBook profile fields
  bio               String?   @db.Text
  bioLastUpdated    DateTime?
  bioViewCount      Int       @default(0)
  xUsername         String?   // X/Twitter handle (without @)
  allowTipsFromBook Boolean   @default(true)
  showInPenguBook   Boolean   @default(true)

  // PenguBook browsing relations
  profileViewsGiven    BioBrowse[] @relation("BioBrowseViewer")
  profileViewsReceived BioBrowse[] @relation("BioBrowseProfile")

  // PenguBook messaging relations
  penguBookMessagesSent     PenguBookMessage[] @relation("PenguBookMessageSender")
  penguBookMessagesReceived PenguBookMessage[] @relation("PenguBookMessageReceiver")

  @@index([agwAddress])
  @@index([createdAt])
  @@index([showInPenguBook, bioLastUpdated])
}

model Tier {
  id           Int      @id @default(autoincrement())
  name         String
  description  String?  @db.Text
  priceAmount  Decimal? // legacy/optional
  durationDays Int
  tipTaxFree   Boolean  @default(false)
  active       Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  memberships TierMembership[]

  // ✅ back-relation to TierPrice
  prices TierPrice[] @relation("TierToPrices")

  @@index([active])
}

model TierPrice {
  id        Int      @id @default(autoincrement())
  tierId    Int
  tokenId   Int
  amount    Decimal
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // ✅ name both sides of the relation
  tier  Tier  @relation("TierToPrices", fields: [tierId], references: [id], onDelete: Cascade)
  token Token @relation("TokenToTierPrices", fields: [tokenId], references: [id], onDelete: Restrict)

  @@unique([tierId, tokenId])
  @@index([tokenId])
}

enum TierMembershipStatus {
  ACTIVE
  EXPIRED
  REVOKED
}

model TierMembership {
  id        Int                  @id @default(autoincrement())
  userId    Int
  tierId    Int
  startedAt DateTime             @default(now())
  expiresAt DateTime
  txHash    String?              @unique
  status    TierMembershipStatus @default(ACTIVE)
  createdAt DateTime             @default(now())

  // BACK-RELATIONS now have opposites on User and Tier
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  tier Tier @relation(fields: [tierId], references: [id], onDelete: Restrict)

  @@unique([userId, tierId, status], map: "uniq_user_tier_status") // one ACTIVE membership per (user,tier)
  @@index([userId, tierId, expiresAt])
  @@index([userId, status, expiresAt])
}

model Match {
  id             Int       @id @default(autoincrement())
  status         String
  wagerAtomic    Decimal   @default(0)
  potAtomic      Decimal   @default(0)
  tokenId        Int
  challengerId   Int?
  joinerId       Int?
  challengerMove String?
  joinerMove     String?
  result         String?
  rakeAtomic     Decimal   @default(0)
  winnerUserId   Int?
  messageId      String?
  channelId      String?
  offerDeadline  DateTime?
  createdAt      DateTime  @default(now())

  Challenger User? @relation("Challenger", fields: [challengerId], references: [id])
  Joiner     User? @relation("Joiner", fields: [joinerId], references: [id])
  Token      Token @relation(fields: [tokenId], references: [id])

  @@index([status, offerDeadline])
  @@index([createdAt])
  @@index([challengerId])
  @@index([joinerId])
}

enum TipStatus {
  PENDING
  COMPLETED
  REFUNDED
}

model Tip {
  id           Int       @id @default(autoincrement())
  fromUserId   Int?
  toUserId     Int?
  tokenId      Int
  amountAtomic Decimal   @default(0)
  feeAtomic    Decimal   @default(0)
  taxAtomic    Decimal   @default(0) // exact tax amount debited at creation
  note         String?
  status       TipStatus @default(PENDING)
  refundedAt   DateTime?
  createdAt    DateTime  @default(now())

  From  User?  @relation("TipFrom", fields: [fromUserId], references: [id])
  To    User?  @relation("TipTo", fields: [toUserId], references: [id])
  Token Token @relation(fields: [tokenId], references: [id])

  // PenguBook message relation
  penguBookMessages PenguBookMessage[] @relation("PenguBookTipMessage")

  @@index([createdAt])
  @@index([status])
  @@index([fromUserId])
  @@index([toUserId])
}

enum GroupTipStatus {
  PENDING
  ACTIVE
  EXPIRED
  REFUNDED
  FAILED
}

model GroupTip {
  id          Int      @id @default(autoincrement())
  creatorId   Int?
  tokenId     Int
  totalAmount Decimal
  taxAtomic   Decimal  @default(0) // exact tax amount debited at creation
  duration    Int
  messageId   String?
  channelId   String?
  guildId     String?
  status      String   // Keep as String for backward compatibility
  expiresAt   DateTime
  refundedAt  DateTime?
  createdAt   DateTime @default(now())

  Creator User?           @relation("GroupTipCreator", fields: [creatorId], references: [id])
  Token   Token           @relation(fields: [tokenId], references: [id])
  claims  GroupTipClaim[]

  @@index([status, expiresAt])
  @@index([createdAt])
  @@index([creatorId])
  @@index([guildId])
}

enum GroupContributionStatus {
  PENDING
  CLAIMED
  REFUNDED
}

model GroupTipClaim {
  id         Int                      @id @default(autoincrement())
  groupTipId Int
  userId     Int?
  status     GroupContributionStatus  @default(PENDING)
  claimedAt  DateTime?
  refundedAt DateTime?
  createdAt  DateTime                 @default(now())

  GroupTip GroupTip @relation(fields: [groupTipId], references: [id])
  User     User?    @relation("GroupTipClaims", fields: [userId], references: [id])

  @@unique([groupTipId, userId])
  @@index([status])
  @@index([groupTipId])
  @@index([userId])
}

model Token {
  id               Int      @id @default(autoincrement())
  address          String   @unique
  symbol           String   @unique
  decimals         Int
  active           Boolean  @default(true)
  minDeposit       Decimal  @default(50)
  minWithdraw      Decimal  @default(50)
  tipFeeBps        Int?
  houseFeeBps      Int?
  withdrawMaxPerTx Decimal?
  withdrawDailyCap Decimal?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  balances  UserBalance[]
  matches   Match[]
  tips      Tip[]
  groupTips GroupTip[]

  // ❌ REMOVE this old line:
  // tiers     Tier[]

  // ✅ back-relation to TierPrice
  tierPrices TierPrice[] @relation("TokenToTierPrices")
}

model UserBalance {
  id      Int     @id @default(autoincrement())
  userId  Int
  tokenId Int
  amount  Decimal @default(0)

  User  User  @relation(fields: [userId], references: [id])
  Token Token @relation(fields: [tokenId], references: [id])

  @@unique([userId, tokenId])
}

model ProcessedDeposit {
  key       String   @id
  createdAt DateTime @default(now())
}

model DepositCursor {
  name      String   @id
  blockHex  String
  updatedAt DateTime @updatedAt
}

model AppConfig {
  id               Int      @id @default(autoincrement())
  minDeposit       Decimal  @default(50)
  minWithdraw      Decimal  @default(50)
  withdrawMaxPerTx Decimal  @default(50)
  withdrawDailyCap Decimal  @default(500)
  houseFeeBps      Int      @default(200)
  tipFeeBps        Int      @default(100)
  emergencyMode    Boolean  @default(false)
  withdrawalsPaused Boolean @default(false)
  tippingPaused    Boolean  @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model ApprovedServer {
  id        Int      @id @default(autoincrement())
  guildId   String   @unique
  note      String?
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Ad {
  id        Int      @id @default(autoincrement())
  text      String
  url       String?
  active    Boolean  @default(true)
  weight    Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Transaction {
  id          Int      @id @default(autoincrement())
  type        String
  userId      Int?
  otherUserId Int?
  guildId     String?
  tokenId     Int?
  amount      Decimal
  fee         Decimal  @default(0)
  txHash      String?
  metadata    String?
  createdAt   DateTime @default(now())

  @@index([createdAt])
  @@index([guildId])
  @@index([type])
  @@index([userId])
}

model WebhookEvent {
  id        Int      @id @default(autoincrement())
  source    String
  key       String   @unique
  status    String
  payload   String
  createdAt DateTime @default(now())

  @@index([createdAt])
}

// PenguBook browsing history - track who viewed whose profile
model BioBrowse {
  id        Int      @id @default(autoincrement())
  viewerId  Int      // who viewed the profile
  profileId Int      // whose profile was viewed
  createdAt DateTime @default(now())
  
  viewer  User @relation("BioBrowseViewer", fields: [viewerId], references: [id], onDelete: Cascade)
  profile User @relation("BioBrowseProfile", fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([viewerId, profileId]) // prevent duplicate views from same user
  @@index([profileId, createdAt]) // for getting recent viewers
  @@index([viewerId, createdAt])  // for user's browsing history
}

// PenguBook messages - direct messages sent with tips from PenguBook
model PenguBookMessage {
  id        Int      @id @default(autoincrement())
  fromUserId Int     // sender
  toUserId   Int     // recipient  
  tipId      Int?    // link to tip if it was a tip message
  message    String  @db.Text
  read       Boolean @default(false)
  createdAt  DateTime @default(now())
  
  from User @relation("PenguBookMessageSender", fields: [fromUserId], references: [id], onDelete: Cascade)
  to   User @relation("PenguBookMessageReceiver", fields: [toUserId], references: [id], onDelete: Cascade)
  tip  Tip? @relation("PenguBookTipMessage", fields: [tipId], references: [id], onDelete: SetNull)
  
  @@index([toUserId, read, createdAt]) // for inbox queries
  @@index([fromUserId, createdAt])     // for sent messages
}
